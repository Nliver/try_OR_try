var (
	score           int
	gameRunning     bool
	combo           int
	lastHitTime     float64 // 上次切水果的时间
	lastMouseX      float64 // 上次鼠标X位置
	lastMouseY      float64 // 上次鼠标Y位置
	wasMousePressed bool    // 上次鼠标是否按下
)

onStart => {
	score = 0
	gameRunning = false // 初始状态：游戏未开始
	combo = 0
	lastHitTime = 0
	lastMouseX = mouseX
	lastMouseY = mouseY
	wasMousePressed = false

	// 使用"开始"精灵显示开始提示
	// Start.say "点击屏幕开始游戏", 999
	Start.setXYpos 0, 0 // 移到屏幕中央
	Start.show

	// 检测鼠标滑动并生成刀光
	forever => {
		if gameRunning { // 只有游戏开始后才检测刀光
			// 检测鼠标按下
			if mousePressed {
				if !wasMousePressed {
					// 刚按下鼠标，记录初始位置
					lastMouseX = mouseX
					lastMouseY = mouseY
					wasMousePressed = true
					// 创建第一个刀光
					Blade.clone
				} else {
					// 鼠标持续按下，检测移动距离（不开方，直接比较平方）
					dx := mouseX - lastMouseX
					dy := mouseY - lastMouseY
					distanceSquared := dx*dx + dy*dy

					// 如果移动距离超过3像素（9 = 3*3），生成新的刀光
					if distanceSquared > 4 {
						Blade.clone
						lastMouseX = mouseX
						lastMouseY = mouseY
					}
				}
			} else {
				wasMousePressed = false
			}
		}
		wait 0.02
	}
}

// 监听游戏开始消息
onMsg "gameStart", => {
	gameRunning = true
	resetTimer
}

// 第二个onStart：生成水果
onStart => {
	forever => {
		if gameRunning {
			wait rand(0.5, 1.0)
			// 随机生成水果或炸弹
			randomNum := rand(1, 7)
			if randomNum == 1 {
				Bomb.clone
			} else if randomNum == 2 {
				Apple.clone
			} else if randomNum == 3 {
				Peach.clone
			} else if randomNum == 4 {
				Basaha.clone
			} else if randomNum == 5 {
				Banana.clone
			} else {
				Watermelon.clone
			}
		}
	}
}

onMsg "scoreAdd", => {
	currentTime := timer

	// 如果距离上次切水果不超过1秒，连击数+1
	if currentTime-lastHitTime <= 1.0 {
		combo++
	} else {
		combo = 1 // 重新开始连击
	}

	// 记录这次切水果的时间
	lastHitTime = currentTime

	// 根据连击数计算得分
	if combo >= 2 {
		score = score + combo
	} else {
		score++
	}
}

onMsg "scoreDelete", => {
	score--
	combo = 0 // 切到炸弹，连击中断
}
