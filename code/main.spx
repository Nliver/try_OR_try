var (
	score           int
	gameRunning     bool
	combo           int
	lastHitTime     float64 // 上次切水果的时间
	lastMouseX      float64 // 上次鼠标X位置
	lastMouseY      float64 // 上次鼠标Y位置
	wasMousePressed bool    // 上次鼠标是否按下
)

onStart => {
	score = 0
	gameRunning = true
	combo = 0
	lastHitTime = 0
	lastMouseX = mouseX
	lastMouseY = mouseY
	wasMousePressed = false

	// 检测鼠标滑动并生成刀光
	forever => {
		// 检测鼠标按下
		if mousePressed {
			if !wasMousePressed {
				// 刚按下鼠标，记录初始位置
				lastMouseX = mouseX
				lastMouseY = mouseY
				wasMousePressed = true
				// 创建第一个刀光
				Blade.clone
			} else {
				// 鼠标持续按下，检测移动距离（不开方，直接比较平方）
				dx := mouseX - lastMouseX
				dy := mouseY - lastMouseY
				distanceSquared := dx*dx + dy*dy

				// 如果移动距离超过10像素（100 = 10*10），生成新的刀光
				// 如果移动距离超过10像素（100 = 10*10），生成新的刀光
				if distanceSquared > 100 {
					Blade.clone
					lastMouseX = mouseX
					lastMouseY = mouseY
				}
			}
		} else {
			wasMousePressed = false
		}
		wait 0.02
	}
}

// 第二个onStart：生成水果
onStart => {
	forever => {
		if gameRunning {
			wait rand(0.5, 1.0)
			// 随机生成水果或炸弹
			randomNum := rand(1, 7)
			if randomNum == 1 {
				Bomb.clone
			} else if randomNum == 2 {
				Apple.clone
			} else if randomNum == 3 {
				Peach.clone
			} else if randomNum == 4 {
				Basaha.clone
			} else if randomNum == 5 {
				Banana.clone
			} else {
				Watermelon.clone
			}
		}
	}
}

onMsg "scoreAdd", => {
	currentTime := timer

	// 如果距离上次切水果不超过1秒，连击数+1
	if currentTime-lastHitTime <= 1.0 {
		combo++
	} else {
		combo = 1 // 重新开始连击
	}

	// 记录这次切水果的时间
	lastHitTime = currentTime

	// 根据连击数计算得分
	if combo >= 2 {
		score = score + combo
	} else {
		score++
	}
}

onMsg "scoreDelete", => {
	score--
	combo = 0 // 切到炸弹，连击中断
}
